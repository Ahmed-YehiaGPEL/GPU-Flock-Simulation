#pragma kernel CSMain
#include "UnityCG.cginc"

#define GROUP_SIZE_X 512
#define GROUP_SIZE_Y 2

struct Boid
{
	float3 Position;
	float3 Direction;
	int IsPredator;
	float2 Padding;
};

RWStructuredBuffer<Boid> boidBuffer;

CBUFFER_START(Params)
float DeltaTime;
float RotationSpeed;
float BoidSpeed;
float3 FlockingTargetPosition;
float NeighbourhoodRadius;
int BoidsCount;
//Just to control values
int AlignScale;
int CohesionScale;
int SeparationScale;
//Better Control for Boids flow, let's specify different radius values for each rule
float FleeRadius;
float AlignmentRadius;
float CohesionRadius;
float SeparationRadius;
float PredatorHuntRadius;
CBUFFER_END

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	Boid boid = boidBuffer[id.x];
	float speed = BoidSpeed;
	float3 separation = float3(0, 0, 0);
	float3 alignment = float3(0, 0, 0);
	float3 cohesion = FlockingTargetPosition; // Always go to the glowing light!

	uint nearbyCount = 1;
	uint cohesionCount = 1;
	uint alignmentCount = 1;
	uint separationCount = 1;

	bool affect = false;
	if (boid.IsPredator == 1)
	{
		speed *= 3;
	}

	for (int i = 0; i < BoidsCount; i++)
	{
		if (i != (int)id.x)
		{
			Boid otherBoid = boidBuffer[i];
			float dist = distance(boid.Position, otherBoid.Position);
			if (boid.IsPredator == 1 && otherBoid.IsPredator == 0)
			{
				//Chase Someone
				if (dist <= PredatorHuntRadius)
				{
					cohesion += otherBoid.Position;
					alignment += otherBoid.Direction;
					cohesionCount = 2;
					alignmentCount = 2;
					break;
				}
				
			}
			else
			{

				if (dist <= SeparationRadius)
				{
					float3 diff = boid.Position - otherBoid.Position;
					float diffLength = length(diff);
					float scaler = clamp(1.0 - diffLength / SeparationRadius, 0.0, 1.0);
					separation += diff * (scaler / diffLength);
					separationCount += 1;
				}
				if (dist <= CohesionRadius)
				{
					cohesion += otherBoid.Position;
					cohesionCount += 1;
				}
				if (dist <= AlignmentRadius)
				{
					alignment += otherBoid.Direction;
					alignmentCount += 1;
				}
				if (otherBoid.IsPredator == 1)
				{
					if (dist <= FleeRadius)
					{
						float3 revDirection = boid.Position - otherBoid.Position;
						alignment = otherBoid.Direction * 5;
						cohesion = revDirection;

						separation += revDirection * length(revDirection);
						alignmentCount = cohesionCount = separationCount = 2;
						speed *= 2;
						break;
					}
				}
			}
		}
	}

	//Averaging ( Mul is faster than Div on GPU)!
	//float averageFactor = 1.0 / nearbyCount;
	alignment /= alignmentCount;
	cohesion /= cohesionCount;

	// Apply Scaling
	alignment *= AlignScale;
	cohesion *= CohesionScale;
	separation *= SeparationScale;

	cohesion = normalize(cohesion - boid.Position); // Get Normalized Direction of Cohesion Vector from self boid! 

	float3 finalDirection = alignment + separation + cohesion;

	float lerpFactor = exp(-1 * RotationSpeed * DeltaTime); //<< Yields Better result than directly interpolating by Rot*DTime!
	boid.Direction = lerp(finalDirection, normalize(boid.Direction), lerpFactor);
	//(Vec) * (float * float) is faster than (Vec * float * float)
	boid.Position += (boid.Direction) * (speed * DeltaTime);

	boidBuffer[id.x] = boid;
}